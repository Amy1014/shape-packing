
** Plucker coordinates harmful
http://liar.bramz.net/


** Problemes avec les coordonnees de Plucker: j'avais un epsilon qui
faisait foirer le truc.

** Essayer d'avoir des listes circulaires de tets incidents pour accelerer
le calcul des cellules duales.

** Variational tet meshing revisited:
  Essayer un truc avec l'energie de Du: il faudrait prendre en compte 
et penaliser fortement la difference de volume. On pourrait avoir un
shema approximant (plutot que interpolant) pour representer la frontiere.

               F   = \sum_{i} inertie( Tet_i \cap \Omega )
avec: inertie( V ) = \int_V \| p - g \|^2 dp

Calcul des gradients:
  On decoupe chaque tetraedre en 4 sous-tetraedres centres en g
  g = 1/4 (p1 + p2 + p3 + p4)
  inertie(g, p1, p2, p3) = |U V W| / 60 * (U^2 + V^2 + W^2 + UV + VW + WU)
  avec: U = p1-g ; V = p2-g; W = p3-g; |U V W| = |(U^V)*W|
   
-> attention au probleme des intersections: il faudra garder la version
formelle / GiNaC
-> la version formelle/GiNaC n'est pas si facile a faire, car les cellules 
primales sont representees sous forme explicite. Si on passe a la forme duale
("convex"), on va avoir des produits vectoriels embetants dans les
derivations.
... Peut-etre peut-on avoir une representation d'un plan support sous
forme d'un triplet de points.

                | p1 p2 p3 p |
(p1, p2, p3) -> | 1  1  1  1 | = 0

(ce qui revient au meme, mais peut-etre un peu plus propre).


  On peut deja essayer avec un domaine convexe (et on clippe la cellule
par le domaine sous forme duale). Ca sera interessant de voir si on
arrive a bien re-obtenir les aretes vives.

  Il va quand meme falloir faire quelquechose avec la continuite de F, qui
n'est pas suffisante si je me souviens bien.

  Pour faire plus simple, on peut essayer un truc: des que le tet a une
intersection non vide avec Omega, on prend en compte son moment d'inertie. 

  Regarder si la formule du moment d'inertie avec une metrique G commute
(je pense que c'est le cas si G est constante). Essayer CVT avec un champ
de G (dans un premier temps en 2D)


  Version 2D:
  - J'ai eu un bug stupide avec la fonction comatrix2x2 qui renvoyait
  la transposee de la comatrice (que je re-transposait apres pour
  resoudre un systeme 2x2, donc je transposais une fois de trop)
  - Un autre bug stupide dans la norme Lp (insertion du meme terme
  plusieurs fois, par exemple U*V et V*U pour la norme L2)
